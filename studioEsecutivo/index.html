<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Studio Esecutivo · TGW3D.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../README/"><img src="../assets/logo.png" alt="TGW3D.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../README/">TGW3D.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../README/">LAR TGW 3D</a></li><li><a class="tocitem" href="../intro/">Introduzione a LAR</a></li><li><a class="tocitem" href="../">Riferimenti API</a></li><li><span class="tocitem">Relazioni</span><ul><li><a class="tocitem" href="../studioPreliminare/">Studio Preliminare</a></li><li class="is-active"><a class="tocitem" href>Studio Esecutivo</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Relazioni</a></li><li class="is-active"><a href>Studio Esecutivo</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Studio Esecutivo</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lauriluca99/TGW-3D.jl/blob/master/docs/src/studioEsecutivo.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Studio-esecutivo"><a class="docs-heading-anchor" href="#Studio-esecutivo">Studio esecutivo</a><a id="Studio-esecutivo-1"></a><a class="docs-heading-anchor-permalink" href="#Studio-esecutivo" title="Permalink"></a></h1><p>Nello studio esecutivo abbiamo analizzato il codice nei notebooks cercando delle possibili  ottimizzazioni. Non è stato possibile ottimizzare tutte le funzioni, infatti le principali modifiche sono state effettuate nelle funzioni:  <strong>frag_face</strong> e <strong>merge_vertices</strong>.</p><p>Per migliorare il codice, sono stati presi in considerazione i libri: <em>Julia High Performance</em> e  <em>Hands-On Julia Programming</em>, nei quali vengono menzionate le seguenti macro  per migliorare le performance e la stabilità del codice:</p><ul><li><code>@async</code>: racchiude l&#39;espressione in un Task ed </li></ul><p>inizierà con l&#39;esecuzione di questa attività procedendo con qualsiasi altra cosa venga dopo nello script, senza aspettare  che il Task termini.</p><ul><li><code>@sync</code>: contrariamente al precedente, questa macro aspetta che </li></ul><p>tutti i Task creati dalla parallelizzazione siano completati prima di proseguire.</p><ul><li><code>Thread.@spawn</code>: Crea un Task e schedula l&#39;esecuzione su un qualsiasi thread disponibile. </li></ul><p>Il Task viene assegnato ad un Thread quando diventa disponibile.</p><ul><li><code>@simd</code>: si utilizza solo nei for per permettere al compilatore di avere</li></ul><p>più libertà nella gestione del ciclo consentendo di riordinarlo.</p><ul><li><p><code>@inbounds</code>: elimina il controllo dei limiti degli array all&#39;interno dell&#39;espressione</p></li><li><p><code>@views</code>: converte le operazioni di taglio sull&#39;array in una data espressione per ritornare </p></li></ul><p>una variabile di tipo View.</p><ul><li><code>@code_warntype</code>: viene utilizzato per individuare i problemi causati dai tipi delle variabili, </li></ul><p>operando conseguentemente con un&#39;assegnazione specifica che riduce la complessità del codice.</p><ul><li><code>@benchmark</code>: questa macro può essere usata solo davanti alle chiamate di funzione.</li></ul><p>Valuta i parametri della funzione separatamente e chiama la funzione più volte per costruire   un campione di tempi di esecuzione.</p><ul><li><code>@btime</code>: simile a <code>@benchmark</code> ma restituisce meno informazioni, quali il tempo minimo </li></ul><p>ed il numero di allocazioni.</p><ul><li><code>@profile</code>: questa macro esegue l&#39;espressione collezionando dei campionamenti periodici.</li></ul><p>Nei campioni si può vedere la gerarchia delle funzioni ed il tempo di esecuzione di ogni riga.</p><h3 id="frag_face"><a class="docs-heading-anchor" href="#frag_face">frag_face</a><a id="frag_face-1"></a><a class="docs-heading-anchor-permalink" href="#frag_face" title="Permalink"></a></h3><p>Utilizzando la macro <code>@code_warntype</code> si individuano molte variabili assegnate al tipo <code>Any</code>.  Questo significa essenzialmente che ci sarà un&#39;allocazione per la posizione della memoria e  l&#39;indirezione al valore effettivo durante l&#39;esecuzione della funzione.</p><pre><code class="language-julia hljs">@benchmark frag_face(Lar.Points(V),EV,FE,[2,3,4,5],2)

BenchmarkTools.Trial: 8171 samples with 1 evaluation.
 Range (min ... max):  376.300 μs ... 59.363 ms   GC (min ... max):  0.00% ... 97.57%
 Time  (median):     436.200 μs               GC (median):     0.00%
 Time  (mean ± σ):   607.541 μs ±  1.482 ms   GC (mean ± σ):  16.21% ±  7.21%

  ▁█▁                                                           
  ███▅▄▄▄▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  376 μs          Histogram: frequency by time         1.17 ms &lt;

 Memory estimate: 265.71 KiB, allocs estimate: 4874.</code></pre><p>Tramite ProfileView otteniamo un grafico in cui si ottiene la misurazione temporale di ogni singola riga di codice.  La larghezza delle barre mostra il tempo trascorso in ogni locazione di chiamata,  mentre la gerarchia di chiamata è rappresentata dalle varie altezze del grafico.</p><p><img src="../assets/image5.png" alt="Grafico di ProfileView della funzione originale"/></p><p>Per ottimizzare la funzione abbiamo assegnato alle variabili locali un tipo deterministico per rimuovere il tipo <code>Any</code> ed avere la funzione <em>type-stable</em>. Inoltre si possono creare delle viste degli array quando c&#39;è un&#39;operazione di slicing,  con la macro <code>@views</code>, le quali permettono di accedere ai valori dell&#39;array  senza dover effettuare una copia.</p><p>Dopo aver eseguito vari test, si è optato per utilizzare la macro <code>@async</code> per parallelizzare il ciclo <em>for</em> che calcola l&#39;intersezione della faccia sigma con le facce in <em>sp_idx[sigma]</em>.</p><p>Quindi, applicando le suddette modifiche, si è raggiunto un tempo minimo di esecuzione inferiore di circa 20% dalla versione originale.</p><pre><code class="language-julia hljs">@benchmark frag_face2(Lar.Points(V),EV,FE,[2,3,4,5],2)

BenchmarkTools.Trial: 9179 samples with 1 evaluation.
 Range (min ... max):  297.300 μs ... 35.314 ms   GC (min ... max):  0.00% ... 97.50%
 Time  (median):     376.200 μs               GC (median):     0.00%
 Time  (mean ± σ):   540.377 μs ±  1.575 ms   GC (mean ± σ):  19.48% ±  6.66%

   ▆█▄                                                          
  ▄███▇▅▄▆▆▅▄▄▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▂▃▃▃▃▃▂▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  297 μs          Histogram: frequency by time          924 μs &lt;

 Memory estimate: 218.65 KiB, allocs estimate: 3873.</code></pre><p><img src="../assets/image7.png" alt="Grafico di ProfileView della funzione modificata"/></p><h3 id="merge_vertices"><a class="docs-heading-anchor" href="#merge_vertices">merge_vertices</a><a id="merge_vertices-1"></a><a class="docs-heading-anchor-permalink" href="#merge_vertices" title="Permalink"></a></h3><p>Anche per quanto riguarda questa funzione abbiamo effettuato un controllo su i vari tipi di variabili assegnati utilizzando  la macro <code>@code_warntype</code>, questa volta però non erano presenti variabili di tipo <code>Any</code> che ci avrebbero dunque destabilizzato i tipi della funzione. Per ottimizzare quest’ ultima abbiamo, un’altra volta, introdotto opportunamente davanti ai cicli <em>for</em>  la macro <code>@async</code> che, parallelizzando le operazioni di calcolo, ci ha permesso di avere un&#39;ottimizzazione del 30% sul tempo di esecuzione.</p><pre><code class="language-julia hljs">@benchmark merge_vertices(Lar.Points(V),Lar.ChainOp(EV),Lar.ChainOp(FE),1e-4)

BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min ... max):  39.200 μs ...  13.339 ms   GC (min ... max):  0.00% ... 99.16%
 Time  (median):     49.400 μs                GC (median):     0.00%
 Time  (mean ± σ):   74.714 μs ± 368.686 μs   GC (mean ± σ):  18.01% ±  3.68%

  ▄█▇▆▅▅▄▄▄▅▄▄▄▄▃▃▃▃▂▂▂▂▁▁▁▁ ▁  ▁   ▁▁▁▂▁▁▁▁▂▁▁▁▁▁▁▁ ▁         ▂
  ████████████████████████████████████████████████████████▆█▆▇ █
  39.2 μs       Histogram: log(frequency) by time       141 μs &lt;

 Memory estimate: 64.00 KiB, allocs estimate: 920.</code></pre><p>Notiamo in seguito come vengono modificati i tempi dopo l&#39;ottimizzazione.</p><pre><code class="language-julia hljs">@benchmark merge_vertices2(Lar.Points(V),Lar.ChainOp(EV),Lar.ChainOp(FE),1e-4)

BenchmarkTools.Trial: 10000 samples with 1 evaluation.
 Range (min ... max):  34.700 μs ... 94.229 ms   GC (min ... max):  0.00% ... 99.75%
 Time  (median):     54.600 μs               GC (median):     0.00%
 Time  (mean ± σ):   99.073 μs ±  1.576 ms   GC (mean ± σ):  27.47% ±  1.73%

   █▅▁                                                         
  ▅████▇▆▆▅▄▄▃▃▂▂▂▂▂▂▂▂▃▂▃▃▃▂▂▂▂▂▂▂▂▂▂▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁ ▂
  34.7 μs         Histogram: frequency by time         218 μs &lt;

 Memory estimate: 56.56 KiB, allocs estimate: 779.</code></pre><h3 id="spatial_arrangement"><a class="docs-heading-anchor" href="#spatial_arrangement">spatial_arrangement</a><a id="spatial_arrangement-1"></a><a class="docs-heading-anchor-permalink" href="#spatial_arrangement" title="Permalink"></a></h3><p>Di nuovo, anche per questa funzione è stato effettuato un controllo su i vari tipi di variabili utilizzando  la macro <code>@code_warntype</code>, quindi abbiamo stabilizzato i tipi delle variabili e parallelizzando le funzioni merge<em>vertices  e frag</em>face, che vengono richiamate all&#39;interno della funzione corrente, abbiamo ottenuto un codice che si comporta come una  versione più veloce del codice precedente risparmiando circa un 40% del tempo di esecuzione.</p><pre><code class="language-julia hljs">@benchmark Lar.Arrangement.spatial_arrangement(Points(V),ChainOp(EV),ChainOp(FE),false)

BenchmarkTools.Trial: 1551 samples with 1 evaluation.
 Range (min ... max):  2.869 ms ... 7.011 ms   GC (min ... max):  0.00% ... 52.79%
 Time  (median):     2.966 ms               GC (median):     0.00%
 Time  (mean ± σ):   3.222 ms ±  846.503 μs   GC (mean ± σ):  6.52% ± 12.05%

  █▆▅▃▄▃▁▁                                                    
  ████████▆▄▅▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅▆▅▃▃▁▃▅▄▁▁▁▄▃▄▁▁▃▁▁▁▁▃ █
  2.87 ms      Histogram: log(frequency) by time     6.47 ms &lt;

 Memory estimate: 3.02 MiB, allocs estimate: 58808.</code></pre><p>Notiamo in seguito come vengono modificati i tempi dopo l&#39;ottimizzazione.</p><pre><code class="language-julia hljs">@benchmark spatial_arrangement(Points(V), ChainOp(EV), ChainOp(FE), false)

BenchmarkTools.Trial: 2612 samples with 1 evaluation.
 Range (min ... max):  1.661 ms ... 6.831 ms   GC (min ... max):  0.00% ... 60.79%
 Time  (median):     1.732 ms               GC (median):     0.00%
 Time  (mean ± σ):   1.911 ms ±  668.375 μs   GC (mean ± σ):  6.28% ± 11.05%

  █▆▅▃▄▃▁▁                                                    
  ████████▆▄▅▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▅▆▅▃▃▁▃▅▄▁▁▁▄▃▄▁▁▃▁▁▁▁▃ █
  1.66 ms      Histogram: log(frequency) by time     5.26 ms &lt;

 Memory estimate: 1.59 MiB, allocs estimate: 28956.</code></pre><h3 id="Azioni-Github"><a class="docs-heading-anchor" href="#Azioni-Github">Azioni Github</a><a id="Azioni-Github-1"></a><a class="docs-heading-anchor-permalink" href="#Azioni-Github" title="Permalink"></a></h3><p>Grazie all&#39;utilizzo del libro <em>Hands-On Julia Programming</em>, in particolare il capitolo 13, si sono costruite diverse <code>Actions</code> di Github, le quali eseguono delle istruzioni specifiche quando Github rileva gli eventi di attivazione corrispondenti.  Ogni volta che c&#39;è un nuovo <code>push</code> sul branch <code>master</code>, viene effettuata una simulazione per verificare che il modulo  <code>TGW3D.jl</code> venga correttamente aggiunto sui sistemi operativi Ubuntu (x86 e x64), Windows (x86 e x64) e macOS (x64).  Inoltre, tramite la libreria <code>Documenter.jl</code>, viene creata la documentazione del nostro progetto,  tramite i <code>docstrings</code> presenti nel modulo TGW3D, ed è inserita sulla pagina di Github corrispondente.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../studioPreliminare/">« Studio Preliminare</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Monday 20 June 2022 13:48">Monday 20 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
